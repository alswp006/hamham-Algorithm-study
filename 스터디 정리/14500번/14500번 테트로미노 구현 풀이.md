``` python
import sys
input = sys.stdin.readline
# 이 문제는 dfs가 효율적인가 빡구현이 효율적인가.. 형이 일단 구현문제라고 해서 빡구현 해벌임..
shape = [# 좌표는 변하면 안되니까 튜플로 저 -> 이 좌표들을 규칙성을 가지고 반복문으로 생성할 방법은 없을까?
    # 사각형
    [(0, 1), (1, 0), (1, 1)],
    # 일자 모양
    [(0, 1), (0, 2), (0, 3)],
    [(1, 0), (2, 0), (3, 0)],
    # ㄴ 모양
    [(1, 0), (2, 0), (2, 1)],
    [(1, 0), (2, 0), (2, -1)],
    [(1, 0), (1, 1), (1, 2)],
    [(0, 1), (1, 0), (2, 0)],
    # ㄱ 모양
    [(0, 1), (0, 2), (1, 0)],
    [(0, 1), (0, 2), (-1, 2)],
    [(0, 1), (1, 1), (2, 1)],
    [(1, 0), (1, 1), (2, 1)],
    # ㅜ 모양
    [(0, 1), (0, 2), (1, 1)],
    [(1, 0), (1, 1), (2, 0)],
    [(0, 1), (0, 2), (-1, 1)],
    [(1, 0), (1, -1), (2, 0)],
    # 용가리 모양
    [(0, 1), (0, 2), (1, 2)],
    [(1, 0), (1, -1), (2, -1)],
    [(0, 1), (1, 1), (1, 2)],
    [(0, 1), (1, 0), (1, -1)],
    [(0, 1), (1, 1), (1, 0)],
    [(0, 1), (1, 1), (-1, 1)]
]

n,m = map(int,input().split())
arr = [list(map(int,input().split())) for i in range(n)]

def get_result(x, y):
    for i in range(len(shape)):
        result = arr[x][y]
        for dx, dy in shape[i]:
            if 0 <= x + dx < n and 0 <= y + dy < m:
                result += arr[x + dx][y + dy]
                continue
            break
        else:
            answer.add(result)

answer = set()

for i in range(n):
    for j in range(m):
        get_result(i, j) # 4중 for문은 보기가 안좋아서 메소드화..
# 이런 경우는  answer가 상당히 많아질텐데 공간복잡도가 너무 커지지 않을까..
print(max(answer))
```
- pypy3 제출 : (메모리 : 113340KB), (시간 : 360ms)

### feedback
- 구현 풀이로 잘 했다.
- for 문을 enhanced for로 쓰자.
- 이렇게 표본 수가 작은 건 구현으로 풀이하는 것이 쉬울 때가 있다.

### 궁금한 점
- set보다 answer를 max로 갱신하니까 시간복잡도가 30ms 줄었다. why?
